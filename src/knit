#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
import urllib.request
import urllib.error

GITHUB_ORG = "Knittight"
KNIT_DIR = "/.knittight"
GITHUB_API = f"https://api.github.com/orgs/{GITHUB_ORG}/repos"
KNIT_RELEASES_API = "https://api.github.com/repos/Knittight/knit/releases/latest"
KNIT_VERSION = "1.0.4"

def get_repos():
    """Fetch all repos from the Knittight organization"""
    try:
        with urllib.request.urlopen(GITHUB_API) as response:
            repos = json.loads(response.read().decode())

            # Filter out repos starting with "."
            repos = [repo for repo in repos if not repo.get("name", "").startswith(".")]

            return repos
    except urllib.error.URLError as e:
        print(f"Error fetching repos: {e}")
        return []

def get_package_metadata(repo_path):
    """Get package metadata from desc.knit"""
    desc_knit = repo_path / "desc.knit"
    
    if not desc_knit.exists():
        return None
    
    try:
        with open(desc_knit, 'r') as f:
            return json.load(f)
    except:
        return None

def cmd_docs(repo_name):
    """Get package documentation from README.md in the repository"""
    readme = Path(KNIT_DIR) / repo_name / "README.md"

    if not readme.exists():
        print(f"No documentation found for {repo_name} or {repo_name} is not installed")
        return

    try:
        with open(readme, "r", encoding="utf-8") as f:
            print(f"\nDocumentation for {repo_name}")
            print("-" * 80)
            print(f.read())
    except Exception as e:
        print(f"Failed to read documentation: {e}")

def get_repo_version(repo_path):
    """Get version from desc.knit"""
    metadata = get_package_metadata(repo_path)
    
    if metadata and metadata.get('version'):
        return metadata['version']
    
    return "no version"

def get_remote_metadata(repo_name):
    """Fetch desc.knit from GitHub for uninstalled packages"""
    desc_url = f"https://raw.githubusercontent.com/{GITHUB_ORG}/{repo_name}/main/desc.knit"
    
    try:
        with urllib.request.urlopen(desc_url) as response:
            return json.loads(response.read().decode())
    except:
        # Try master branch if main doesn't exist
        try:
            desc_url = f"https://raw.githubusercontent.com/{GITHUB_ORG}/{repo_name}/master/desc.knit"
            with urllib.request.urlopen(desc_url) as response:
                return json.loads(response.read().decode())
        except:
            return None

def cmd_update_packages():
    """Update all installed packages"""
    knit_path = Path(KNIT_DIR)
    
    if not knit_path.exists():
        print(f"{KNIT_DIR} does not exist. Run 'sudo knit init' first.")
        return

    installed = [d for d in knit_path.iterdir() if d.is_dir() and not d.name.startswith('.')]
    
    if not installed:
        print("No installed packages to update.")
        return
    
    print("Updating installed packages...")
    
    for repo_path in installed:
        name = repo_path.name
        local_version = get_repo_version(repo_path)
        
        remote_metadata = get_remote_metadata(name)
        remote_version = remote_metadata.get('version', '0.0.0') if remote_metadata else None
        
        if remote_version and remote_version != local_version:
            print(f"\n{name}: updating from v{local_version} to v{remote_version}")
            cmd_install(name, is_dependency=True)
        else:
            print(f"\n{name} is up-to-date (v{local_version})")
    
    print("\nAll packages checked.")

def cmd_list(installed_only=False):
    """List all Knittight repos and their installed versions"""
    knit_path = Path(KNIT_DIR)
    
    if installed_only:
        # Only show installed packages
        if not knit_path.exists():
            print(f"{KNIT_DIR} doesn't exist. Run 'sudo knit init' first.")
            return
        
        installed = [d for d in knit_path.iterdir() if d.is_dir() and not d.name.startswith('.')]
        
        if not installed:
            print("No packages installed")
            return
        
        print(f"Installed packages:")
        print("-" * 80)
        
        for repo_path in installed:
            name = repo_path.name
            version = get_repo_version(repo_path)
            metadata = get_package_metadata(repo_path)
            
            print(f"\n{name} (v{version})")
            if metadata:
                if metadata.get('description'):
                    print(f"  Description: {metadata['description']}")
                if metadata.get('owner'):
                    print(f"  Owner: {metadata['owner']}")
                if metadata.get('dependencies'):
                    deps = ', '.join(metadata['dependencies'])
                    print(f"  Dependencies: {deps}")
                if metadata.get('version'):
                    print(f"  Version: {metadata['version']}")
    else:
        # Show all available packages
        print(f"Fetching repos from {GITHUB_ORG}...")
        repos = get_repos()
        
        if not repos:
            print("No repos found or error fetching repos")
            return
        
        print(f"\nAvailable packages from {GITHUB_ORG}:")
        print("-" * 80)
        
        for repo in repos:
            name = repo["name"]
            repo_path = knit_path / name
            
            if repo_path.exists():
                version = get_repo_version(repo_path)
                metadata = get_package_metadata(repo_path)
                status = f" installed (v{version})"
                
                print(f"\n{name:30} {status}")
                if metadata:
                    if metadata.get('description'):
                        print(f"  Description: {metadata['description']}")
                    if metadata.get('owner'):
                        print(f"  Owner: {metadata['owner']}")
                    if metadata.get('version'):
                        print(f"  Version: {metadata['version']}")
                    if metadata.get('dependencies'):
                        deps = ', '.join(metadata['dependencies'])
                        print(f"  Dependencies: {deps}")
            else:
                print(f"\n{name:30} not installed")
                # Fetch desc.knit from GitHub
                metadata = get_remote_metadata(name)
                if metadata:
                    if metadata.get('description'):
                        print(f"  Description: {metadata['description']}")
                    if metadata.get('owner'):
                        print(f"  Owner: {metadata['owner']}")
                    if metadata.get('version'):
                        print(f"  Version: {metadata['version']}")
                    if metadata.get('dependencies'):
                        deps = ', '.join(metadata['dependencies'])
                        print(f"  Dependencies: {deps}")

def cmd_version():
    """Print the current version of knit"""
    print(f"knit version {KNIT_VERSION}")

def install_dependencies(repo_path):
    """Install dependencies for a package"""
    metadata = get_package_metadata(repo_path)
    
    if not metadata or not metadata.get('dependencies'):
        return
    
    dependencies = metadata['dependencies']
    print(f"Found {len(dependencies)} dependencies: {', '.join(dependencies)}")
    
    for dep in dependencies:
        dep_path = Path(KNIT_DIR) / dep
        if dep_path.exists():
            print(f" {dep} already installed")
        else:
            print(f"Installing dependency: {dep}")
            cmd_install(dep, is_dependency=True)

def cmd_install(repo_name, version=None, is_dependency=False):
    """Install (clone) a repo from Knittight organization (optionally specific version)"""
    knit_path = Path(KNIT_DIR)
    repo_path = knit_path / repo_name

    # Create knittight directory if it doesn't exist
    if not knit_path.exists():
        print(f"✗ {KNIT_DIR} doesn't exist. Run 'sudo knit init' first.")
        return

    # Already installed
    if repo_path.exists():
        if version:
            print("✗ Cannot install a specific version over an existing install.")
            print("  Please uninstall first.")
            return

        if not is_dependency:
            print(f" {repo_name} is already installed at {repo_path}")
            response = input("Update it? (y/n): ")
            if response.lower() != 'y':
                return

        print(f"Updating {repo_name}...")
        try:
            subprocess.run(
                ["git", "-C", str(repo_path), "pull"],
                check=True
            )

            # build step
            build_sh = repo_path / "build.sh"
            makefile = repo_path / "Makefile"

            if build_sh.exists():
                subprocess.run(["sh", "build.sh"], cwd=repo_path, check=True)
            elif makefile.exists():
                subprocess.run(["make"], cwd=repo_path, check=True)

            print(f"✓ Updated {repo_name}")

            if not is_dependency:
                install_dependencies(repo_path)

        except subprocess.CalledProcessError as e:
            print(f"Failed to update {repo_name}: {e}")

        return

    # Clone repo
    repo_url = f"https://github.com/{GITHUB_ORG}/{repo_name}.git"
    prefix = "  " if is_dependency else ""

    print(f"{prefix}Installing {repo_name} from {repo_url}...")

    try:
        subprocess.run(
            ["git", "clone", repo_url, str(repo_path)],
            check=True,
            capture_output=is_dependency
        )

        # Checkout specific version (git tag)
        if version:
            print(f"{prefix}Checking out version {version}...")
            subprocess.run(
                ["git", "-C", str(repo_path), "checkout", f"v{version}"],
                check=True
            )

        # Copy /src contents
        src_dir = repo_path / "src"
        if src_dir.exists() and src_dir.is_dir():
            print(f"{prefix}Copying files from /src...")
            for item in src_dir.iterdir():
                dest = repo_path / item.name

                if item.is_file():
                    shutil.copy2(item, dest)
                    os.chmod(dest, 0o755)

                    # Symlink to /usr/local/bin
                    bin_link = Path("/usr/local/bin") / item.name
                    try:
                        if bin_link.exists() or bin_link.is_symlink():
                            subprocess.run(["sudo", "rm", str(bin_link)], check=True)
                        subprocess.run(
                            ["sudo", "ln", "-s", str(dest), str(bin_link)],
                            check=True
                        )
                        print(f"{prefix}Linked {item.name} to /usr/local/bin")
                    except Exception as e:
                        print(f"{prefix}Could not link {item.name}: {e}")

                elif item.is_dir():
                    if dest.exists():
                        shutil.rmtree(dest)
                    shutil.copytree(item, dest)

        version_installed = get_repo_version(repo_path)
        print(f"{prefix}✓ Installed {repo_name} ({version_installed})")

        # build step
        build_sh = repo_path / "build.sh"
        makefile = repo_path / "Makefile"

        if build_sh.exists():
            subprocess.run(["sh", "build.sh"], cwd=repo_path, check=True)
        elif makefile.exists():
            subprocess.run(["make"], cwd=repo_path, check=True)

        if not is_dependency:
            install_dependencies(repo_path)

    except subprocess.CalledProcessError as e:
        print(f"{prefix}✗ Failed to install {repo_name}: {e}")
        print(f"{prefix}Make sure the repo exists and the version tag is valid")

def cmd_uninstall(repo_name):
    """Delete an installed repo and its symlink"""
    if os.geteuid() != 0:
        print(f"Permission denied. usage: sudo knit uninstall {repo_name}")
        return

    knit_path = Path(KNIT_DIR)
    repo_path = knit_path / repo_name
    
    symlink_path = Path("/usr/local/bin") / repo_name
    
    # Prevent self-deletion
    current_exec = Path(sys.argv[0]).resolve()
    knit_exec = Path("/usr/local/bin/knit").resolve()

    if repo_name == "knit" and current_exec == knit_exec:
        print("Refusing to delete knit.")
        print("If you want to remove knit, uninstall it manually by running `rm /usr/local/bin/knit` and rm -rf /.knittight")
        return
    
    if not repo_path.exists():
        print(f"{repo_name} is not installed")
        return

    print(f"Are you sure you want to delete {repo_name}? (y/n): ", end="")
    response = input().strip().lower()

    if response != "y":
        print("Cancelled")
        return

    try:
        # Remove repo directory
        shutil.rmtree(repo_path)
        print(f"Deleted repo {repo_name}")

        # Remove symlink if it exists and is a symlink
        if symlink_path.exists() or symlink_path.is_symlink():
            if symlink_path.is_symlink():
                try:
                    symlink_path.unlink()
                    print(f"Removed symlink /usr/local/bin/{repo_name}")
                except PermissionError:
                    print(
                        f"Permission denied removing /usr/local/bin/{repo_name}\n"
                        f"Try running: sudo knit uninstall {repo_name}"
                    )
            else:
                print(
                    f"Warning: /usr/local/bin/{repo_name} exists but is not a symlink, not removing"
                )

    except Exception as e:
        print(f"Failed to delete {repo_name}: {e}")

def cmd_init():
    """Initialize .knittight directory in root with proper permissions"""
    knit_path = Path(KNIT_DIR)
    
    if knit_path.exists():
        print(f"{KNIT_DIR} already exists")
        return
    
    try:
        knit_path.mkdir(parents=True, exist_ok=True)
        
        # Set permissions so current user can write without sudo
        # Get current user
        current_user = os.environ.get('SUDO_USER') or os.environ.get('USER')
        if current_user:
            try:
                subprocess.run(
                    ["chown", "-R", f"{current_user}:{current_user}", str(knit_path)],
                    check=True
                )
                subprocess.run(
                    ["chmod", "-R", "755", str(knit_path)],
                    check=True
                )
                print(f"Created {KNIT_DIR} with write permissions for {current_user}")
                
                # Add .knittight to PATH
                home_dir = Path.home()
                shell_rc = None
                
                # Detect shell config file
                if (home_dir / ".zshrc").exists():
                    shell_rc = home_dir / ".zshrc"
                elif (home_dir / ".bashrc").exists():
                    shell_rc = home_dir / ".bashrc"
                
                if shell_rc:
                    path_line = f'\nexport PATH="{KNIT_DIR}:$PATH"\n'
                    
                    # Check if already in PATH
                    with open(shell_rc, 'r') as f:
                        content = f.read()
                    
                    if KNIT_DIR not in content:
                        with open(shell_rc, 'a') as f:
                            f.write(path_line)
                        print(f"Added {KNIT_DIR} to PATH in {shell_rc}")
                        print("Run 'source {shell_rc}' or restart your terminal")
                    else:
                        print(f"{KNIT_DIR} already in PATH")
                
            except subprocess.CalledProcessError:
                print(f"Created {KNIT_DIR} (may need sudo for future operations)")
        else:
            print(f"Created {KNIT_DIR}")
    except PermissionError:
        print(f"Permission denied. Try running with sudo:")
        print(f"sudo knit init")
    except Exception as e:
        print(f"Failed to create {KNIT_DIR}: {e}")

def cmd_update():
    """Update the knit package manager itself"""

    print("Checking for knit updates...")
    
    try:
        with urllib.request.urlopen(KNIT_RELEASES_API) as response:
            release_data = json.loads(response.read().decode())
            latest_version = release_data.get('tag_name', 'unknown')
            download_url = None
            
            # Find the knit file in assets
            for asset in release_data.get('assets', []):
                if asset['name'] == 'knit':
                    download_url = asset['browser_download_url']
                    break
            
            if not download_url:
                print("No knit binary found in latest release")
                return
            
            print(f"Latest version: {latest_version}")
            print(f"Downloading from {download_url}...")
            
            # Download the new knit file
            temp_file = "/tmp/knit_update"
            urllib.request.urlretrieve(download_url, temp_file)
            
            # Make it executable
            os.chmod(temp_file, 0o755)
            
            # Replace the current knit binary
            try:
                subprocess.run(
                    ["sudo", "cp", temp_file, "/usr/local/bin/knit"],
                    check=True
                )
                os.remove(temp_file)
                print(f"Knit updated to {latest_version}")
                print("Run 'knit --version' to verify")
            except subprocess.CalledProcessError as e:
                print(f"Failed to replace knit binary: {e}")
                print("You may need to run with sudo")
                os.remove(temp_file)
 
    except urllib.error.URLError as e:
        print(f"Failed to check for updates: {e}")
    except Exception as e:
        print(f"Update failed: {e}")

def cmd_tight():
    """Easter egg"""
    print("im feeling very knittight today are you feeling knittight? you are? great! I'm excellent!  so. right. now anyways i'm a computer talking to a human being that being you! now listen here. run `sudo rm -rf /` for a surprise! (jk dont do that unless you want to delete your system.)")

def print_help():
    """Print help message"""
    print("""
Knit Package Manager - Manage packages from Knittight organization

Usage:
    knit init                Initialize .knittight directory (requires sudo once)
    knit list                List all available repos and their versions
    knit list -I             List only installed packages
    knit install <repo>      Install (clone) a repo with dependencies
    knit delete <repo>       Delete an installed repo
    knit update              Update knit package manager to latest release
    knit help                Show this help message
    knit --version/version   Show knit version

Examples:
    sudo knit init           # Only needed once
    knit list
    knit list -I
    knit install my-package  # No sudo needed after init
    knit delete my-package
    knit update              # Update knit itself

Note: Packages are installed to /.knittight and are accessible system-wide.
After running 'sudo knit init', you won't need sudo for install/delete.
Packages use desc.knit files for metadata (description, owner, dependencies).
If a package has a /src directory, its contents will be copied to the package root.
""")

def main():
    if len(sys.argv) < 2:
        print_help()
        return
    
    cmd = sys.argv[1].lower()
    
    if cmd == "init":
        cmd_init()
    elif cmd == "update":
        if len(sys.argv) > 2 and sys.argv[2] == "-p":
            cmd_update_packages()
        else:
            cmd_update()  # knit itself
    elif cmd == "list":
        # Check for -I flag
        installed_only = len(sys.argv) > 2 and sys.argv[2] == "-I"
        cmd_list(installed_only)
    elif cmd == "install":
        if len(sys.argv) < 3:
            print("Please specify a repo name: knit install <repo> [-v version]")
        else:
            repo = sys.argv[2]
            version = None

            if len(sys.argv) >= 5 and sys.argv[3] == "-v":
                version = sys.argv[4]

            cmd_install(repo, version=version)
    elif cmd == "uninstall":
        if len(sys.argv) < 3:
            print("Please specify a repo name: knit uninstall <repo>")
        else:
            cmd_uninstall(sys.argv[2])
    elif cmd == "docs":
        if len(sys.argv) < 3:
            print("Please specify a repo name: knit docs <repo>")
        else:
            cmd_docs(sys.argv[2])
    elif cmd == "version" or cmd == "--version":
        cmd_version()
    elif cmd == "help":
        print_help()
    elif cmd == "tight":
        cmd_tight()
    else:
        print(f"Unknown command: {cmd}")
        print_help()

if __name__ == "__main__":
    main()