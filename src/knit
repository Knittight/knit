#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
import urllib.request
import urllib.error

GITHUB_ORG = "Knittight"
KNIT_DIR = "/.knittight"
GITHUB_API = f"https://api.github.com/orgs/{GITHUB_ORG}/repos"
KNIT_RELEASES_API = "https://api.github.com/repos/Knittight/knit/releases/latest"
KNIT_VERSION = "1.0.1"

def get_repos():
    """Fetch all repos from the Knittight organization"""
    try:
        with urllib.request.urlopen(GITHUB_API) as response:
            repos = json.loads(response.read().decode())
            return repos
    except urllib.error.URLError as e:
        print(f"Error fetching repos: {e}")
        return []

def get_package_metadata(repo_path):
    """Get package metadata from desc.knit"""
    desc_knit = repo_path / "desc.knit"
    
    if not desc_knit.exists():
        return None
    
    try:
        with open(desc_knit, 'r') as f:
            return json.load(f)
    except:
        return None

def get_repo_version(repo_path):
    """Get version from desc.knit"""
    metadata = get_package_metadata(repo_path)
    
    if metadata and metadata.get('version'):
        return metadata['version']
    
    return "no version"

def get_remote_metadata(repo_name):
    """Fetch desc.knit from GitHub for uninstalled packages"""
    desc_url = f"https://raw.githubusercontent.com/{GITHUB_ORG}/{repo_name}/main/desc.knit"
    
    try:
        with urllib.request.urlopen(desc_url) as response:
            return json.loads(response.read().decode())
    except:
        # Try master branch if main doesn't exist
        try:
            desc_url = f"https://raw.githubusercontent.com/{GITHUB_ORG}/{repo_name}/master/desc.knit"
            with urllib.request.urlopen(desc_url) as response:
                return json.loads(response.read().decode())
        except:
            return None

def cmd_list(installed_only=False):
    """List all Knittight repos and their installed versions"""
    knit_path = Path(KNIT_DIR)
    
    if installed_only:
        # Only show installed packages
        if not knit_path.exists():
            print(f"{KNIT_DIR} doesn't exist. Run 'sudo knit init' first.")
            return
        
        installed = [d for d in knit_path.iterdir() if d.is_dir() and not d.name.startswith('.')]
        
        if not installed:
            print("No packages installed")
            return
        
        print(f"Installed packages:")
        print("-" * 80)
        
        for repo_path in installed:
            name = repo_path.name
            version = get_repo_version(repo_path)
            metadata = get_package_metadata(repo_path)
            
            print(f"\n{name} (v{version})")
            if metadata:
                if metadata.get('description'):
                    print(f"  Description: {metadata['description']}")
                if metadata.get('owner'):
                    print(f"  Owner: {metadata['owner']}")
                if metadata.get('dependencies'):
                    deps = ', '.join(metadata['dependencies'])
                    print(f"  Dependencies: {deps}")
                if metadata.get('version'):
                    print(f"  Version: {metadata['version']}")
    else:
        # Show all available packages
        print(f"Fetching repos from {GITHUB_ORG}...")
        repos = get_repos()
        
        if not repos:
            print("No repos found or error fetching repos")
            return
        
        print(f"\nAvailable packages from {GITHUB_ORG}:")
        print("-" * 80)
        
        for repo in repos:
            name = repo["name"]
            repo_path = knit_path / name
            
            if repo_path.exists():
                version = get_repo_version(repo_path)
                metadata = get_package_metadata(repo_path)
                status = f" installed (v{version})"
                
                print(f"\n{name:30} {status}")
                if metadata:
                    if metadata.get('description'):
                        print(f"  Description: {metadata['description']}")
                    if metadata.get('owner'):
                        print(f"  Owner: {metadata['owner']}")
                    if metadata.get('version'):
                        print(f"  Version: {metadata['version']}")
                    if metadata.get('dependencies'):
                        deps = ', '.join(metadata['dependencies'])
                        print(f"  Dependencies: {deps}")
            else:
                print(f"\n{name:30} not installed")
                # Fetch desc.knit from GitHub
                metadata = get_remote_metadata(name)
                if metadata:
                    if metadata.get('description'):
                        print(f"  Description: {metadata['description']}")
                    if metadata.get('owner'):
                        print(f"  Owner: {metadata['owner']}")
                    if metadata.get('version'):
                        print(f"  Version: {metadata['version']}")
                    if metadata.get('dependencies'):
                        deps = ', '.join(metadata['dependencies'])
                        print(f"  Dependencies: {deps}")

def cmd_version():
    """Print the current version of knit"""
    print(f"knit version {KNIT_VERSION}")


def install_dependencies(repo_path):
    """Install dependencies for a package"""
    metadata = get_package_metadata(repo_path)
    
    if not metadata or not metadata.get('dependencies'):
        return
    
    dependencies = metadata['dependencies']
    print(f"Found {len(dependencies)} dependencies: {', '.join(dependencies)}")
    
    for dep in dependencies:
        dep_path = Path(KNIT_DIR) / dep
        if dep_path.exists():
            print(f" {dep} already installed")
        else:
            print(f"Installing dependency: {dep}")
            cmd_install(dep, is_dependency=True)

def cmd_install(repo_name, is_dependency=False):
    """Install (clone) a repo from Knittight organization"""
    knit_path = Path(KNIT_DIR)
    repo_path = knit_path / repo_name
    
    # Create knittight directory if it doesn't exist
    if not knit_path.exists():
        print(f"✗ {KNIT_DIR} doesn't exist. Run 'sudo knit init' first.")
        return
    
    if repo_path.exists():
        if not is_dependency:
            print(f" {repo_name} is already installed at {repo_path}")
            response = input("Update it? (y/n): ")
            if response.lower() != 'y':
                return
        print(f"Updating {repo_name}...")
        try:
            subprocess.run(
                ["git", "-C", str(repo_path), "pull"],
                check=True
            )
            print(f"✓ Updated {repo_name}")
            
            # Install dependencies after update
            if not is_dependency:
                install_dependencies(repo_path)
        except subprocess.CalledProcessError as e:
            print(f"Failed to update {repo_name}: {e}")
        return
    
    # Clone the repo
    repo_url = f"https://github.com/{GITHUB_ORG}/{repo_name}.git"
    prefix = "  " if is_dependency else ""
    print(f"{prefix}Installing {repo_name} from {repo_url}...")
    
    try:
        subprocess.run(
            ["git", "clone", repo_url, str(repo_path)],
            check=True,
            capture_output=is_dependency
        )
        
        # Check if there's a /src directory and copy its contents
        src_dir = repo_path / "src"
        if src_dir.exists() and src_dir.is_dir():
            print(f"{prefix}Copying files from /src...")
            for item in src_dir.iterdir():
                dest = repo_path / item.name
                if item.is_file():
                    shutil.copy2(item, dest)
                    
                    # Make executable and symlink to /usr/local/bin
                    os.chmod(dest, 0o755)  # Make it executable
                    bin_link = Path("/usr/local/bin") / item.name
                    try:
                        if bin_link.exists() or bin_link.is_symlink():
                            subprocess.run(["sudo", "rm", str(bin_link)], check=True)
                        subprocess.run(["sudo", "ln", "-s", str(dest), str(bin_link)], check=True)
                        print(f"{prefix}Linked {item.name} to /usr/local/bin")
                    except Exception as e:
                        print(f"{prefix}Could not link {item.name}: {e}")
                        
                elif item.is_dir():
                    if dest.exists():
                        shutil.rmtree(dest)
                    shutil.copytree(item, dest)
        
        version = get_repo_version(repo_path)
        print(f"{prefix}✓ Installed {repo_name} (v{version})")
        
        # Install dependencies after successful install
        if not is_dependency:
            install_dependencies(repo_path)
    except subprocess.CalledProcessError as e:
        print(f"{prefix}✗ Failed to install {repo_name}: {e}")
        print(f"{prefix}Make sure the repo exists at {repo_url}")

def cmd_delete(repo_name):
    """Delete an installed repo"""
    knit_path = Path(KNIT_DIR)
    repo_path = knit_path / repo_name
    
    if not repo_path.exists():
        print(f" {repo_name} is not installed")
        return
    
    print(f"Are you sure you want to delete {repo_name}? (y/n): ", end="")
    response = input()
    
    if response.lower() == 'y':
        try:
            shutil.rmtree(repo_path)
            print(f"Deleted {repo_name}")
        except Exception as e:
            print(f"Failed to delete {repo_name}: {e}")
    else:
        print("Cancelled")

def cmd_init():
    """Initialize .knittight directory in root with proper permissions"""
    knit_path = Path(KNIT_DIR)
    
    if knit_path.exists():
        print(f"{KNIT_DIR} already exists")
        return
    
    try:
        knit_path.mkdir(parents=True, exist_ok=True)
        
        # Set permissions so current user can write without sudo
        # Get current user
        current_user = os.environ.get('SUDO_USER') or os.environ.get('USER')
        if current_user:
            try:
                subprocess.run(
                    ["chown", "-R", f"{current_user}:{current_user}", str(knit_path)],
                    check=True
                )
                subprocess.run(
                    ["chmod", "-R", "755", str(knit_path)],
                    check=True
                )
                print(f"Created {KNIT_DIR} with write permissions for {current_user}")
                
                # Add .knittight to PATH
                home_dir = Path.home()
                shell_rc = None
                
                # Detect shell config file
                if (home_dir / ".zshrc").exists():
                    shell_rc = home_dir / ".zshrc"
                elif (home_dir / ".bashrc").exists():
                    shell_rc = home_dir / ".bashrc"
                
                if shell_rc:
                    path_line = f'\nexport PATH="{KNIT_DIR}:$PATH"\n'
                    
                    # Check if already in PATH
                    with open(shell_rc, 'r') as f:
                        content = f.read()
                    
                    if KNIT_DIR not in content:
                        with open(shell_rc, 'a') as f:
                            f.write(path_line)
                        print(f"Added {KNIT_DIR} to PATH in {shell_rc}")
                        print("Run 'source {shell_rc}' or restart your terminal")
                    else:
                        print(f"{KNIT_DIR} already in PATH")
                
            except subprocess.CalledProcessError:
                print(f"Created {KNIT_DIR} (may need sudo for future operations)")
        else:
            print(f"Created {KNIT_DIR}")
    except PermissionError:
        print(f"Permission denied. Try running with sudo:")
        print(f"sudo knit init")
    except Exception as e:
        print(f"Failed to create {KNIT_DIR}: {e}")

def cmd_update():
    """Update the knit package manager itself"""
    print("Checking for knit updates...")
    
    try:
        with urllib.request.urlopen(KNIT_RELEASES_API) as response:
            release_data = json.loads(response.read().decode())
            latest_version = release_data.get('tag_name', 'unknown')
            download_url = None
            
            # Find the knit file in assets
            for asset in release_data.get('assets', []):
                if asset['name'] == 'knit':
                    download_url = asset['browser_download_url']
                    break
            
            if not download_url:
                print("No knit binary found in latest release")
                return
            
            print(f"Latest version: {latest_version}")
            print(f"Downloading from {download_url}...")
            
            # Download the new knit file
            temp_file = "/tmp/knit_update"
            urllib.request.urlretrieve(download_url, temp_file)
            
            # Make it executable
            os.chmod(temp_file, 0o755)
            
            # Replace the current knit binary
            try:
                subprocess.run(
                    ["sudo", "cp", temp_file, "/usr/local/bin/knit"],
                    check=True
                )
                os.remove(temp_file)
                print(f"Knit updated to {latest_version}")
                print("Run 'knit --version' to verify")
            except subprocess.CalledProcessError as e:
                print(f"Failed to replace knit binary: {e}")
                print("You may need to run with sudo")
                os.remove(temp_file)
    
    except urllib.error.URLError as e:
        print(f"Failed to check for updates: {e}")
    except Exception as e:
        print(f"Update failed: {e}")
def cmd_tight():
    """Easter egg"""
    print("im feeling very knittight today are you feeling knittight? you are? great! I'm excellent!  so. right. now anyways i'm a computer talking to a human being that being you! now listen here. run `sudo rm -rf /` for a surprise! (jk dont do that unless you want to delete your system.)")

def print_help():
    """Print help message"""
    print("""
Knit Package Manager - Manage packages from Knittight organization

Usage:
    knit init                Initialize .knittight directory (requires sudo once)
    knit list                List all available repos and their versions
    knit list -I             List only installed packages
    knit install <repo>      Install (clone) a repo with dependencies
    knit delete <repo>       Delete an installed repo
    knit update              Update knit package manager to latest release
    knit help                Show this help message
    knit --version/version   Show knit version

Examples:
    sudo knit init           # Only needed once
    knit list
    knit list -I
    knit install my-package  # No sudo needed after init
    knit delete my-package
    knit update              # Update knit itself

Note: Packages are installed to /.knittight and are accessible system-wide.
After running 'sudo knit init', you won't need sudo for install/delete.
Packages use desc.knit files for metadata (description, owner, dependencies).
If a package has a /src directory, its contents will be copied to the package root.
""")

def main():
    if len(sys.argv) < 2:
        print_help()
        return
    
    cmd = sys.argv[1].lower()
    
    if cmd == "init":
        cmd_init()
    elif cmd == "update":
        cmd_update()
    elif cmd == "list":
        # Check for -I flag
        installed_only = len(sys.argv) > 2 and sys.argv[2] == "-I"
        cmd_list(installed_only)
    elif cmd == "install":
        if len(sys.argv) < 3:
            print("Please specify a repo name: knit install <repo>")
        else:
            cmd_install(sys.argv[2])
    elif cmd == "delete":
        if len(sys.argv) < 3:
            print("Please specify a repo name: knit delete <repo>")
        else:
            cmd_delete(sys.argv[2])
    elif cmd == "version" or cmd == "--version":
        cmd_version()
    elif cmd == "help":
        print_help()
    elif cmd == "tight":
        cmd_tight()
    else:
        print(f"Unknown command: {cmd}")
        print_help()

if __name__ == "__main__":
    main()